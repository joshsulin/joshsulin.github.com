---
layout: post
title:  "第一课: Rust是什么, 为什么强烈推荐大家学习它!"
date:   2021-07-24 20:19:20 +0800
categories: Rust
tags: ['Rust']
---

2021 年，Stack Overflow 发布了他们的年度开发者报告，报告中一个很有意思的数据是 Rust 一骑绝尘，打败一众编程语言，夺得了`“最受程序员喜爱的编程语言”`这个称号，而且这已经是` Rust 连续第五年蝉联`这个荣誉了。

那么，Rust究竟是一门怎样的语言? 为什么连续五年夺得"最受程序员喜爱的编程语言"称号。让我们先从Rust的诞生背景说起。

### Rust诞生背景

最初，Rust 是 Mozilla 公司员工 Graydon Hoare 的私人项目。Hoare 是一名职业的编程语言工程师，他的日常工作就是给其他的语言开发编译器和工具集，但并不会参与背后的设计工作。老干这种活儿，自然而然的，Hoare 就萌生了开发一门编程语言的想法，这门语言就是 Rust。

2006 年，Hoare 开始在业余时间设计并开发 Rust 的早期版本。任何一门新技术的诞生，都是为了解决某些问题，Rust 也不例外。

自操作系统诞生以来，系统级主流编程语言从汇编语言到 C 到 C++，已经发展了近 50 个年头，但依然存在两个难题：

- 很难编写内存安全的代码；
+ 很难编写线程安全的代码。

这两个难题存在的本质原因是 C/C++ 属于类型不安全的语言，它们薄弱的内存管理机制导致了很多常见的漏洞。其实 20 世纪 80 年代也出现过非常优秀的语言，比如 Ada 语言。Ada 拥有诸多优秀的特性：可以在编译期进行类型检查、没有 GC 式确定性内存管理、内置安全并发模型、无数据竞争、系统级硬实时编程等。但它的性能和同时期的 C/C++ 相比确实是有差距的。那个时代计算资源匮乏，大家追求的是性能。所以，大家都宁愿牺牲安全性来换取性能。这也是 C/C++ 得以普及的原因。

但随着硬件演进的速度不断加快，Hoare 认为，未来的互联网除了关注性能，一定还会高度关注安全性和并发性，以前那些青睐于 C 和 C++ 的设计方式将会不断的发生改变。

基于这样的认知，Hoare 在设计时对 Rust 的期望是：性能可以和 C/C++ 媲美，还能保证安全性，同时可以提供高效的开发效率，代码还得容易维护。

可以说，Rust 诞生之初就是奔着 C/C++ 去的，Hoare 在一次采访中就曾说过：
> 纵观周围，大部分堆栈级的系统代码都是用 C 或者 C++ 编写的，而那正是我们的目标所在。同时，我们的目标人群正是那些纠结的 C/C++ 程序员，实际上就是我们自己。如果你也和我们一样，不断重复地迫使自己因为 C++ 的高效和部署特性而选择它来进行系统级的开发，却又希望可以编写一些更加安全而省心的程序的话，希望我们可以给你一些帮助。

正是因为 Hoare 以这种观点作为基石，才使得今天的`Rust成为了一门同时追求安全、并发和性能的现代系统级编程语言`。

### Rust语言设计思想

为了达成目标，Rust 语言遵循了四条设计哲学：

#### 安全

来看安全。Rust 是静态的，拥有丰富的类型系统和所有权语义模型，保证了内存安全性和线程安全性。 举个例子，C 语言中很容易出现整数溢出，如果被黑客利用，就会出现安全问题，而 Rust 中的每个值都只能被一个所有者拥有，所以 C 语言常遇到的这类问题，对 Rust 来说都不是问题。

同时，借助类型系统的强大，Rust 编译器可以在编译期就对类型进行检查，及时发现内存不安全的问题，使开发者能在编译阶段就将诸多类型错误扼杀于萌芽之中。当然，凡事都有两面性，之前，我一位从 C++ 转向 Rust 的程序员朋友就吐槽过，“C++ 是调试的时候想撞墙，而 Rust 是编译的时候想撞墙。”

#### 并发

来看并发。并发和并行是技术圈内永不会过时的话题，而 Rust 在设计层面就提供了一整套机制来保证并发的安全性。举个例子，数据并发在多线程程序中是一个常见的危险因素，而 Rust 通过所有权模型，非常清晰地定义了一个安全的边界，保证你的代码不会出问题。

#### 高效

来看高效。Rust 没有运行时机制，也没有垃圾回收机制，所以它非常快并且内存效率极高。同时，Rust 可以为关键性能服务提供支持，还可以轻松地与其他语言集成。

#### 零成本抽象

除了安全、并发、高效，Rust 还追求高效开发和性能。

编程语言如果想做到高效开发，就必须拥有一定的抽象表达能力。关于抽象表达能力，最具代表性的语言就是Ruby。Ruby 代码和 Rust 代码的对比示意如代码清单 1-1 所示。

```Ruby
# Ruby代码
5.times{ puts "Hello Ruby"}
2.days.from_now;
```

```Rust
# Rust代码
5.times(|| println!(“Hello Rust”));
2.days().from_now();
```

代码清单 1-1：Ruby 代码和 Rust 代码对比示意

在代码清单 1-1 中，代码第 2 行和第 3 行是 Ruby 代码，分别表示“输出 5 次"Hello Ruby"”和“从现在开始两天之后”，代码的抽象表达能力已经非常接近自然语言。再看第 5 行和第 6 行的 Rust 代码，它和 Ruby 语言的抽象表达能力是不相上下的。

但是 Ruby 的抽象表达能力完全是靠牺牲性能换来的。而 Rust 的抽象是零成本的，Rust 的抽象并不会存在运行时性能开销，这一切都是在编译期完成的。代码清单 1-1 中的迭代 5 次的抽象代码，在编译期会被展开成和手写汇编代码相近的底层代码，所以不存在运行时因为解释这一层抽象而产生的性能开销。对于一门系统级编程语言而言，运行时零成本是非常重要的。这一点，Rust 做到了。Rust 中零成本抽象的基石就是泛型和 trait。

### Rust语言现状和未来

### Rust语言如何执行

### 本课小结
