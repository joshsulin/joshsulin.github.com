---
layout: post
title:  "第二课: 理解Rust的所有权"
date:   2021-07-31 20:19:20 +0800
categories: Rust
tags: ['Rust']
---

在 Stack Overflow 进行的开发者调查中，Rust 已经连续第五年成为最受欢迎的编程语言。开发人员喜欢 Rust 的原因有很多，其中之一是它的内存安全保证。

Rust通过一个叫做所有权的功能来保证内存安全。所有权的工作方式与其他语言中的垃圾收集器不同，因为它只是由编译器在编译时需要检查的一组规则组成。如果所有权规则没有得到遵守，编译器将不会进行编译。借用检查器是一个编译器组件，它确保你的代码遵循所有权。

对于没有垃圾收集器的语言，你需要明确地分配和释放内存空间。当涉及到大型代码库时，这很快就会变得乏味和具有挑战性。

值得庆幸的是，内存管理是由Rust编译器使用所有权模型处理的。Rust编译器会自动插入一个drop语句来释放内存。它使用所有权模型来决定释放内存的位置；当所有者超出范围时，内存就被释放了。

### 栈和堆是什么？

栈和堆都是内存存储段，可供你的代码在运行时使用。对于大多数编程语言来说，开发人员通常不关心栈和堆中的内存分配情况。然而，由于Rust是一种系统编程语言，数值如何存储（在栈或堆中）对语言的行为方式至关重要。

这里有一个关于如何存储在栈中的例子：让我们想想桌子上的一摞书。这些书的排列方式是，最后一本书放在书堆的顶部，第一本书在底部。理想情况下，我们不会想把最下面的书从书堆下面滑出来，在上面选一本书来读会更容易。

这正是内存在栈中的存储方式；它使用了后进先出的方法。在这里，它按照得到的顺序存储数值，但以相反的顺序删除它们。同样重要的是要注意，所有存储在栈中的数据在编译时都有一个已知的大小。

堆的内存分配与栈的内存分配方式不同。想一想，要为朋友买一件衬衫。你不知道你朋友穿的衬衫的确切尺寸，但经常看到他，你认为他可能是中号或大号。虽然你并不完全确定，但你还是买了大号的，因为即使他是中号的，他仍然能够穿上它。这就是堆中内存分配的工作方式。当你有一个值（你的朋友），而你不知道它需要的确切内存量（T恤衫的大小），你就为这个值申请一个特定的空间量。分配器在堆中找到一个足够大的位置，并将该位置标记为使用中。这是堆和栈之间的一个重要区别：我们不需要知道被存储在堆中的值的确切大小。

与栈相比，堆中没有组织。将数据推入和推出栈是很容易的，因为所有的东西都是有组织的，并遵循一个特定的顺序。系统明白，当你把一个值推入栈时，它将保持在顶部，而当你需要从栈中取出一个值时，你将检索最后存储的值。

然而，在堆中情况并非如此。在堆上的分配包括搜索一个足够大的内存空间，以匹配你所请求的内存量，并返回一个地址，该地址将被存储在栈中。从堆中检索一个值需要你跟随一个指针到该值在堆中存储的地方。

在堆上进行分配看起来就像书本索引，存储在堆中的值的指针被存储在栈中。然而，分配器还需要搜索一个足够大的空间来容纳该值。

一个函数的局部变量存储在函数栈中，而数据类型，如String、Vector、Box等则存储在堆中。了解Rust的内存管理很重要，以确保应用程序的行为符合预期。

### 所有权规则

所有权有三个基本规则来预测内存是如何存储在栈中和堆中的:

1、Rust中的每个值都有一个称为其所有者的变量名。

```Rust
let x = 5; // x is the owner of the value "5"
```

2、同一时间只能有一个所有者。

3、当所有者超出作用域时, 该值将被删除。

```Rust
fn main() {
	{
		// scope begins
		let s = String::from("hello"); // s comes into scope
	}
	// the value of s is dropped at this point, it is out of scope
}
```

在我们的介绍中，我们明确了一个事实：所有权并不像垃圾收集器系统(GC)，事实上，Rust并不涉及垃圾收集器系统。大多数编程语言要么使用垃圾收集器，要么要求开发者自己分配和释放内存。

在所有权中，我们为自己申请内存，当所有者超出范围时，该值将被放弃，内存被释放。这正是第三条所有权规则所解释的。为了更好地理解这一点，让我们看一个例子。

```Rust
// memory allocation in the stack
fn main() {
	{ 
		// a is not valid here
		let a = 5; // a is valid here
		// do stuff with a
	}
	// println!("{}", a)a is no longer valid at this point, it is out of scope
}
```

这个例子非常简单，这就是栈中的内存分配的工作方式。一个内存块（a）在栈中被分配，因为我们知道它的值5将占用的确切空间。然而，这并不总是这样的。有时，你需要为一个可增长的值分配内存空间，而你在编译时并不知道其大小。

在这种情况下，内存是在堆上分配的，你首先必须请求内存，如下面的例子所示:

```Rust
fn main() {
    {
			let mut s = String::from("hello"); // s is valid from this point forward

			s.push_str(", world!"); // push_str() appends a literal to a String

			println!("{}", s); // This will print `hello, world!` 
    }// s is no longer valid here
}
```

我们可以随心所欲地追加字符串，因为它是可变的，所以在编译时很难知道所需的确切大小。因此，我们在程序中需要一个与字符串大小相当的内存空间。

```Rust
let mut s = String::from("hello") // requesting for space in the heap, the size of a String.
```

当变量超出作用域时，Rust 所有权特性允许返回(释放)内存。

### 克隆和复制

在本节中，我们将研究所有权如何影响Rust中的某些功能，首先是克隆和复制功能。

对于像整数这样有已知大小的值来说，将该值复制到另一个值中比较容易。例如:

```Rust
fn main() {
    let a = "5";
    let b = a; // copy the value a into b
    println!("{}", a) // 5
    println!("{}", b) // 5
}
```

因为 a 存储在栈中，所以更容易复制它的值为 b 创建另一个副本。但堆中存储的值并非如此:

```Rust
fn main() {
    let a = String::from("hello");
    let b = a; // copy the value a into b
    println!("{}", a) // This will throw an error because a has been moved or ownership has been transferred
    println!("{}", b) // hello
}
```

当你运行这个命令时，你会得到一个错误`error[E0382]: borrow of moved value: "a"`，我解释了堆中的值是如何像索引过程一样存储的，其中指针存储在栈中。在Rust术语中，移动意味着内存的所有权被转移给另一个所有者。

当您复制存储在堆上的值时，系统会自动只复制指针，而忽略堆数据。因为数据可以有一个所有者，所以字符串的所有权从 a 转移到 b。

### 所有权和函数

### 引用和借用

### 切片

### 总结

所有权是Rust的一个重要特征。Rust开发者越了解所有权，就越容易写出可扩展的代码。许多开发者喜欢Rust的原因就是因为这个特性，一旦你掌握了这个特性，你就可以写出高效的代码，并预测结果，而不会被Rust拉下水!

在这篇文章中，我们已经看到了所有权的基本知识，它的规则，以及如何在我们的程序中应用它们。我们还看了Rust的一些没有所有权的功能，以及如何无误地使用它们。




当你已经掌握一门语言后, 再来学习Rust时, 有些知识可能是相通的, 但很多东西是非常不同的。Rust循环语句与其它语言可能有熟悉的语法, 编写Rust循环与其它熟悉可能有熟悉的，但在幕后，Rust正在将这些循环翻译成它自己的语法。如果你自己学习这种风格，你会发现Rust循环在日常编程中的能力和作用要大得多。

Rust使用一种模式匹配的形式来说明你的循环的每一步可能产生的结果。这确保了你不需要写那么多的测试；Rust为你提供了一些关于被迭代的条件的类型和边界的保证。这有助于你的测试专注于更相关的事情，也使你的测试更加合理。

让我们来看看Rust是如何处理循环的。
